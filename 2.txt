如何不靠耐心测试

通常，我们编写的软件会直接与那些我们称之为“肮脏的”服务交互。通俗地说，服务对我们的应用来说是至关重要的，它们之间的交互是我们设计好的，但这会带来我们不希望的副作用――就是那些在我们自己测试的时候不希望的功能。
比如，可能我们正在写一个社交软件并且想测试一下“发布到Facebook的功能”，但是我们不希望每次运行测试集的时候都发布到Facebook上。
Python的unittest库中有一个子包叫unittest.mock――或者你把它声明成一个依赖，简化为mock――这个模块提供了非常强大并且有用的方法，通过它们可以模拟或者屏敝掉这些不受我们希望的方面。

注意：mock是最近收录在Python 3.3标准库中的；之前发布的版本必须通过 PyPI下载Mock库。
Rhys
Rhys
翻译于 5天前
0人顶
顶 翻译的不错哦!
恐惧系统调用

再举一个例子，考虑系统调用，我们将在余下的文章中讨论它们。不难发现，这些都可以考虑使用模拟：无论你是想写一个脚本弹出一个CD驱动，或者是一个web服务用来删除/tmp目录下的缓存文件，或者是一个socket服务来绑定一个TCP端口，这些调用都是在你单元测试的时候是不被希望的方面。
作为一个开发人员，你更关心你的库是不是成功的调用了系统函数来弹出CD，而不是体验每次测试的时候CD托盘都打开。
作为一个开发人员，你更关心你的库是不是成功调用了系统函数来弹出CD（带着正确的参数等）。而不是体验每次测试的时候CD托盘都打开（或者更糟，很多次，当一个单元测试运行的时候，很多测试点都涉及到了弹出代码）。
同样地，保持你的单元测试效率和性能意味着要还要保留一些自动化测试之外的“缓慢代码”，比如文件系统和网络的访问。
对于我们的第一个例子，我们要重构一个从原始到使用mock的一个标准Python测试用例。我们将会证明如何用mock写一个测试用例使我们的测试更智能、更快，并且能暴露更多关于我们的软件工作的问题。
对于这些重构，我们已经从根本上改变了该测试的运行方式。现在，我们有一个内部的对象，让我们可以使用另一个功能验证。
潜在的陷阱
第一件要注意的事情就是，我们使用的mock.patch方法的装饰位于mymodule.os模拟对象，并注入到我们测试案例的模拟方法。是模拟os更有意义，还是它在mymodule.os的参考更有意义？
当然，当Python出现在进口和管理模块时，用法是非常的灵活。在运行时，该mymodule模块有自己的os操作系统――被引入到自己的范围内的模块。因此，如果我们模拟os系统，我们不会看到模拟测试在mymodule模块的影响。
这句话需要深刻的记住：